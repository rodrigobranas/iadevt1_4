---
alwaysApply: false
---

# Testing Standards

## Testing Framework
- Use **Jest** for test scenarios and assertions
- Use **Sinon** for test patterns (stub, spy, mock)
- Run tests with: `yarn test`

## Test Organization

### Directory Structure
- All tests must be placed in `/test` directory
- **Never** place tests in `/src` alongside source files
- Organize tests by type:
  - `/test/unit` - Unit tests
  - `/test/integration` - Integration tests

### File Naming
- Test files must use `.test.ts` extension
- Name pattern: `[feature-name].test.ts`

## Test Design Principles

### Independence
- Tests must be completely independent
- Each test should be runnable in isolation
- Never create dependencies between tests

### Structure
Follow **Arrange-Act-Assert** or **Given-When-Then** pattern:
```typescript
describe('UserService', () => {
  it('should create a new user', () => {
    // Arrange / Given
    const userData = { name: 'John', email: 'john@example.com' };
    
    // Act / When
    const result = userService.create(userData);
    
    // Assert / Then
    expect(result).toBeDefined();
    expect(result.id).toBeTruthy();
  });
});
```

### Date/Time Handling
- Mock `Date` objects when testing time-dependent behavior
- Ensure tests are repeatable regardless of when they run

## Test Categories

### Integration Tests (`/test/integration`)
Tests that depend on external resources:
- HTTP requests
- Database operations
- Message queues
- File system operations
- External APIs

### Unit Tests (`/test/unit`)
Tests without external dependencies:
- Pure business logic
- Domain entities
- Value objects
- Utility functions

## Testing Guidelines

### HTTP Endpoints
- Create integration tests for HTTP endpoints
- **Do not use** libraries like `supertest`
- Focus on:
  - Main flow functionality
  - Alternative flows
  - Status codes
  - Error messages
- Leave business rule variations for use case tests

### Use Cases
- Test all use cases thoroughly
- Cover main flow and at least one alternative flow (exception handling)
- Use **stub pattern** to avoid external API calls
- Keep these as unit tests when possible

### Domain Layer
- Test all domain entities and value objects
- Cover all business rules and variations
- Test edge cases comprehensively
- Keep all domain tests at unit level

## Best Practices

### Test Scope
- Focus on testing **one behavior per test**
- Avoid writing overly complex tests
- Keep tests small and focused

### Code Coverage
- Ensure complete code coverage for new code
- All production code should be covered by tests

### Assertions
- Create consistent and comprehensive assertions
- Verify all relevant aspects of the tested behavior
- Don't just test the "happy path"

### Resource Management
- Always close database connections after tests
- Clean up message queue connections
- Release any external resources in `afterEach` or `afterAll`

### Test Initialization
- Use `beforeEach` for test setup when needed
- Keep initialization logic simple and focused

## Example Test Structure

```typescript
describe('OrderService', () => {
  let orderService: OrderService;
  let mockRepository: any;

  beforeEach(() => {
    mockRepository = sinon.stub();
    orderService = new OrderService(mockRepository);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('createOrder', () => {
    it('should create an order successfully', () => {
      // Test implementation
    });

    it('should throw error when customer not found', () => {
      // Test implementation
    });
  });
});
```# Testing Standards

## Testing Framework
- Use **Jest** for test scenarios and assertions
- Use **Sinon** for test patterns (stub, spy, mock)
- Run tests with: `yarn test`

## Test Organization

### Directory Structure
- All tests must be placed in `/test` directory
- **Never** place tests in `/src` alongside source files
- Organize tests by type:
  - `/test/unit` - Unit tests
  - `/test/integration` - Integration tests

### File Naming
- Test files must use `.test.ts` extension
- Name pattern: `[feature-name].test.ts`

## Test Design Principles

### Independence
- Tests must be completely independent
- Each test should be runnable in isolation
- Never create dependencies between tests

### Structure
Follow **Arrange-Act-Assert** or **Given-When-Then** pattern:
```typescript
describe('UserService', () => {
  it('should create a new user', () => {
    // Arrange / Given
    const userData = { name: 'John', email: 'john@example.com' };
    
    // Act / When
    const result = userService.create(userData);
    
    // Assert / Then
    expect(result).toBeDefined();
    expect(result.id).toBeTruthy();
  });
});
```

### Date/Time Handling
- Mock `Date` objects when testing time-dependent behavior
- Ensure tests are repeatable regardless of when they run

## Test Categories

### Integration Tests (`/test/integration`)
Tests that depend on external resources:
- HTTP requests
- Database operations
- Message queues
- File system operations
- External APIs

### Unit Tests (`/test/unit`)
Tests without external dependencies:
- Pure business logic
- Domain entities
- Value objects
- Utility functions

## Testing Guidelines

### HTTP Endpoints
- Create integration tests for HTTP endpoints
- **Do not use** libraries like `supertest`
- Focus on:
  - Main flow functionality
  - Alternative flows
  - Status codes
  - Error messages
- Leave business rule variations for use case tests

### Use Cases
- Test all use cases thoroughly
- Cover main flow and at least one alternative flow (exception handling)
- Use **stub pattern** to avoid external API calls
- Keep these as unit tests when possible

### Domain Layer
- Test all domain entities and value objects
- Cover all business rules and variations
- Test edge cases comprehensively
- Keep all domain tests at unit level

## Best Practices

### Test Scope
- Focus on testing **one behavior per test**
- Avoid writing overly complex tests
- Keep tests small and focused

### Code Coverage
- Ensure complete code coverage for new code
- All production code should be covered by tests

### Assertions
- Create consistent and comprehensive assertions
- Verify all relevant aspects of the tested behavior
- Don't just test the "happy path"

### Resource Management
- Always close database connections after tests
- Clean up message queue connections
- Release any external resources in `afterEach` or `afterAll`

### Test Initialization
- Use `beforeEach` for test setup when needed
- Keep initialization logic simple and focused

## Example Test Structure

```typescript
describe('OrderService', () => {
  let orderService: OrderService;
  let mockRepository: any;

  beforeEach(() => {
    mockRepository = sinon.stub();
    orderService = new OrderService(mockRepository);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('createOrder', () => {
    it('should create an order successfully', () => {
      // Test implementation
    });

    it('should throw error when customer not found', () => {
      // Test implementation
    });
  });
});
```