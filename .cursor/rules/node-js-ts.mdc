---
alwaysApply: true
---

# Node.js & TypeScript Standards

## Language Requirements
- All source code must be written in **TypeScript**
- Use **Yarn** as the standard package manager
- Run scripts with `yarn` commands

## Type Definitions
- Install type definitions for all libraries
- Example: `jest` requires `@types/jest`
- Always validate typing correctness before completing tasks

## Variable Declaration

### Best Practices
- Use `const` wherever possible
- Use `let` only when reassignment is necessary
- **Never use `var`** for variable declarations

### Examples
```typescript
// Good
const API_URL = 'https://api.example.com';
const users = [];
let currentIndex = 0;

// Bad
var oldVariable = 'avoid this';
```

## Class Design

### Property Visibility
- Declare class properties as `private` or `readonly`
- Avoid using `public` modifier (it's implicit)

### Example
```typescript
class UserService {
  private readonly repository: UserRepository;
  private cache: Map<string, User>;
  
  constructor(repository: UserRepository) {
    this.repository = repository;
    this.cache = new Map();
  }
}
```

## Functional Programming

### Array Operations
Prefer functional methods over imperative loops:
- `find()` - locate single element
- `filter()` - select multiple elements
- `map()` - transform elements
- `reduce()` - aggregate values

### Example
```typescript
// Good
const activeUsers = users.filter(user => user.isActive);
const userNames = users.map(user => user.name);
const totalAge = users.reduce((sum, user) => sum + user.age, 0);

// Avoid
const activeUsers = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].isActive) {
    activeUsers.push(users[i]);
  }
}
```

## Asynchronous Programming

### Async/Await
- Always use `async/await` for Promise handling
- Avoid callbacks and `.then()` chains

### Example
```typescript
// Good
async function fetchUser(id: string): Promise<User> {
  try {
    const response = await api.get(`/users/${id}`);
    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch user: ${error.message}`);
  }
}

// Avoid
function fetchUser(id: string, callback: (err: Error, user?: User) => void) {
  api.get(`/users/${id}`)
    .then(response => callback(null, response.data))
    .catch(error => callback(error));
}
```

## Type Safety

### No Any Type
- **Never use `any`** type
- Create proper interfaces or types for all data structures
- Use `unknown` when type is truly unknown and add type guards

### Example
```typescript
// Good
interface UserData {
  id: string;
  name: string;
  email: string;
}

function processUser(data: UserData): void {
  // Implementation
}

// Bad
function processUser(data: any): void {
  // Loses all type safety
}
```

## Module System

### Imports
- Always use ES6 `import` syntax
- Never use `require()`

### Exports
- Use `export default` for single exports
- Use named exports for multiple exports
- Never use `module.exports`

### Examples
```typescript
// Single export
export default class UserService {
  // Implementation
}

// Multiple exports
export interface User {
  id: string;
  name: string;
}

export class UserRepository {
  // Implementation
}

// Importing
import UserService from './UserService';
import { User, UserRepository } from './user';
```

## Architecture Guidelines

### Dependency Management
- Avoid circular dependencies
- Use dependency injection patterns
- Keep module dependencies clear and minimal

### Example Structure
```typescript
// Good - Clear dependency flow
// UserController → UserService → UserRepository → Database

// Bad - Circular dependency
// UserService → NotificationService → UserService
```

## Additional Best Practices

- Validate all external inputs
- Handle errors appropriately
- Use meaningful variable and function names
- Keep functions small and focused
- Document complex logic with JSDoc comments when necessary# Node.js & TypeScript Standards

## Language Requirements
- All source code must be written in **TypeScript**
- Use **Yarn** as the standard package manager
- Run scripts with `yarn` commands

## Type Definitions
- Install type definitions for all libraries
- Example: `jest` requires `@types/jest`
- Always validate typing correctness before completing tasks

## Variable Declaration

### Best Practices
- Use `const` wherever possible
- Use `let` only when reassignment is necessary
- **Never use `var`** for variable declarations

### Examples
```typescript
// Good
const API_URL = 'https://api.example.com';
const users = [];
let currentIndex = 0;

// Bad
var oldVariable = 'avoid this';
```

## Class Design

### Property Visibility
- Declare class properties as `private` or `readonly`
- Avoid using `public` modifier (it's implicit)

### Example
```typescript
class UserService {
  private readonly repository: UserRepository;
  private cache: Map<string, User>;
  
  constructor(repository: UserRepository) {
    this.repository = repository;
    this.cache = new Map();
  }
}
```

## Functional Programming

### Array Operations
Prefer functional methods over imperative loops:
- `find()` - locate single element
- `filter()` - select multiple elements
- `map()` - transform elements
- `reduce()` - aggregate values

### Example
```typescript
// Good
const activeUsers = users.filter(user => user.isActive);
const userNames = users.map(user => user.name);
const totalAge = users.reduce((sum, user) => sum + user.age, 0);

// Avoid
const activeUsers = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].isActive) {
    activeUsers.push(users[i]);
  }
}
```

## Asynchronous Programming

### Async/Await
- Always use `async/await` for Promise handling
- Avoid callbacks and `.then()` chains

### Example
```typescript
// Good
async function fetchUser(id: string): Promise<User> {
  try {
    const response = await api.get(`/users/${id}`);
    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch user: ${error.message}`);
  }
}

// Avoid
function fetchUser(id: string, callback: (err: Error, user?: User) => void) {
  api.get(`/users/${id}`)
    .then(response => callback(null, response.data))
    .catch(error => callback(error));
}
```

## Type Safety

### No Any Type
- **Never use `any`** type
- Create proper interfaces or types for all data structures
- Use `unknown` when type is truly unknown and add type guards

### Example
```typescript
// Good
interface UserData {
  id: string;
  name: string;
  email: string;
}

function processUser(data: UserData): void {
  // Implementation
}

// Bad
function processUser(data: any): void {
  // Loses all type safety
}
```

## Module System

### Imports
- Always use ES6 `import` syntax
- Never use `require()`

### Exports
- Use `export default` for single exports
- Use named exports for multiple exports
- Never use `module.exports`

### Examples
```typescript
// Single export
export default class UserService {
  // Implementation
}

// Multiple exports
export interface User {
  id: string;
  name: string;
}

export class UserRepository {
  // Implementation
}

// Importing
import UserService from './UserService';
import { User, UserRepository } from './user';
```

## Architecture Guidelines

### Dependency Management
- Avoid circular dependencies
- Use dependency injection patterns
- Keep module dependencies clear and minimal

### Example Structure
```typescript
// Good - Clear dependency flow
// UserController → UserService → UserRepository → Database

// Bad - Circular dependency
// UserService → NotificationService → UserService
```

## Additional Best Practices

- Validate all external inputs
- Handle errors appropriately
- Use meaningful variable and function names
- Keep functions small and focused
- Document complex logic with JSDoc comments when necessary