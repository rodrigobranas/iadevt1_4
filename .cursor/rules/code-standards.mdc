---
alwaysApply: true
---
# Code Standards

## Language Requirements
- All source code must be written in **English**

## Naming Conventions

### Case Styles
- **camelCase**: Methods, functions, and variables
  - `getUserById()`, `calculateTotal()`, `isActive`
- **PascalCase**: Classes and interfaces
  - `UserService`, `OrderRepository`, `IPaymentGateway`
- **kebab-case**: Files and directories
  - `user-service.ts`, `order-repository.ts`, `payment-gateway/`

### Naming Guidelines
- Avoid abbreviations (exception: well-known terms like `API`, `URL`)
- Keep names descriptive but concise (max 30 characters)
- Use meaningful, self-documenting names

### Examples
```typescript
// Good
const userAuthenticationToken = '...';
const calculateOrderTotal = () => {};
class CustomerRepository {}

// Avoid
const usrAuthTkn = '...';
const calc = () => {};
class CustRepo {}
```

## Code Organization

### Constants and Magic Numbers
- Declare constants for all magic numbers
- Use descriptive names that explain the value's purpose

```typescript
// Good
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_PAGE_SIZE = 20;
const TAX_RATE = 0.08;

// Avoid
if (retries > 3) { ... }
const pageSize = 20;
```

## Functions and Methods

### Naming Rules
- Start with a verb that clearly describes the action
- Never start with a noun

```typescript
// Good
function createUser() {}
function validateEmail() {}
function isValidDate() {}

// Avoid
function userCreation() {}
function emailValidation() {}
```

### Parameter Guidelines
- Limit to 3 parameters maximum
- Use objects for multiple related parameters

```typescript
// Good
function createOrder(customerId: string, items: OrderItem[], options?: OrderOptions) {}

// Better (when many parameters)
interface CreateOrderParams {
  customerId: string;
  items: OrderItem[];
  shippingAddress: Address;
  billingAddress: Address;
  discountCode?: string;
}

function createOrder(params: CreateOrderParams) {}
```

## Clean Code Principles

### Side Effects
- Avoid side effects in functions
- Separate queries from commands (CQRS pattern)
- A function should either return data OR cause a side effect, never both

```typescript
// Good - Query
function getUser(id: string): User {
  return database.findUser(id);
}

// Good - Command
function updateUser(id: string, data: UserData): void {
  database.updateUser(id, data);
}

// Avoid - Mixed responsibility
function getUserAndLog(id: string): User {
  const user = database.findUser(id);
  logger.info(`User ${id} accessed`); // Side effect in query
  return user;
}
```

### Control Flow

#### Early Returns
- Use early returns to avoid deep nesting
- Maximum nesting level: 2

```typescript
// Good
function processOrder(order: Order): void {
  if (!order) {
    throw new Error('Order is required');
  }
  
  if (!order.items.length) {
    throw new Error('Order must have items');
  }
  
  // Process order
}

// Avoid
function processOrder(order: Order): void {
  if (order) {
    if (order.items.length) {
      // Process order
    } else {
      throw new Error('Order must have items');
    }
  } else {
    throw new Error('Order is required');
  }
}
```

#### Flag Parameters
- Never use boolean flags to control function behavior
- Create separate functions instead

```typescript
// Good
function saveUser(user: User): void { }
function saveUserAsDraft(user: User): void { }

// Avoid
function saveUser(user: User, isDraft: boolean): void {
  if (isDraft) {
    // Save as draft
  } else {
    // Save normally
  }
}
```

## Code Size Limits

### Methods and Functions
- Maximum 50 lines per function
- If exceeding, consider extracting helper functions

### Classes
- Maximum 300 lines per class
- If exceeding, consider splitting responsibilities

## Dependency Management

### Dependency Inversion
- Always invert dependencies for external resources
- Apply in use cases and interface adapters
- Use interfaces to define contracts

```typescript
// Good
interface PaymentGateway {
  processPayment(amount: number): Promise<PaymentResult>;
}

class PaymentService {
  constructor(private gateway: PaymentGateway) {}
  
  async processOrder(order: Order): Promise<void> {
    await this.gateway.processPayment(order.total);
  }
}

// Avoid
class PaymentService {
  async processOrder(order: Order): Promise<void> {
    const stripe = new Stripe(); // Direct dependency
    await stripe.charge(order.total);
  }
}
```

## Code Formatting

### Blank Lines
- Avoid blank lines within methods and functions
- Use blank lines between methods/functions
- Group related code together

### Comments
- Avoid comments when possible
- Write self-documenting code instead
- Use comments only for:
  - Complex algorithms explanation
  - Business rule clarification
  - TODO/FIXME with ticket references

### Variable Declaration
- Never declare multiple variables on same line
- Declare variables close to where they're used

```typescript
// Good
const firstName = user.firstName;
const lastName = user.lastName;

// Avoid
const firstName = user.firstName, lastName = user.lastName;
```

## Design Principles

### Composition Over Inheritance
- Prefer composition to class inheritance
- Use interfaces for contracts
- Compose behaviors through dependency injection

```typescript
// Good - Composition
interface Logger {
  log(message: string): void;
}

class UserService {
  constructor(private logger: Logger) {}
}

// Avoid - Inheritance
class BaseService {
  protected log(message: string): void {}
}

class UserService extends BaseService {}
```

## Best Practices Summary

1. Write code in English with clear naming
2. Keep functions small and focused
3. Minimize nesting with early returns
4. Separate concerns clearly
5. Prefer composition over inheritance
6. Write self-documenting code
7. Apply SOLID principles consistently
8. Maintain consistent code style throughout the project# Code Standards

## Language Requirements
- All source code must be written in **English**

## Naming Conventions

### Case Styles
- **camelCase**: Methods, functions, and variables
  - `getUserById()`, `calculateTotal()`, `isActive`
- **PascalCase**: Classes and interfaces
  - `UserService`, `OrderRepository`, `IPaymentGateway`
- **kebab-case**: Files and directories
  - `user-service.ts`, `order-repository.ts`, `payment-gateway/`

### Naming Guidelines
- Avoid abbreviations (exception: well-known terms like `API`, `URL`)
- Keep names descriptive but concise (max 30 characters)
- Use meaningful, self-documenting names

### Examples
```typescript
// Good
const userAuthenticationToken = '...';
const calculateOrderTotal = () => {};
class CustomerRepository {}

// Avoid
const usrAuthTkn = '...';
const calc = () => {};
class CustRepo {}
```

## Code Organization

### Constants and Magic Numbers
- Declare constants for all magic numbers
- Use descriptive names that explain the value's purpose

```typescript
// Good
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_PAGE_SIZE = 20;
const TAX_RATE = 0.08;

// Avoid
if (retries > 3) { ... }
const pageSize = 20;
```

## Functions and Methods

### Naming Rules
- Start with a verb that clearly describes the action
- Never start with a noun

```typescript
// Good
function createUser() {}
function validateEmail() {}
function isValidDate() {}

// Avoid
function userCreation() {}
function emailValidation() {}
```

### Parameter Guidelines
- Limit to 3 parameters maximum
- Use objects for multiple related parameters

```typescript
// Good
function createOrder(customerId: string, items: OrderItem[], options?: OrderOptions) {}

// Better (when many parameters)
interface CreateOrderParams {
  customerId: string;
  items: OrderItem[];
  shippingAddress: Address;
  billingAddress: Address;
  discountCode?: string;
}

function createOrder(params: CreateOrderParams) {}
```

## Clean Code Principles

### Side Effects
- Avoid side effects in functions
- Separate queries from commands (CQRS pattern)
- A function should either return data OR cause a side effect, never both

```typescript
// Good - Query
function getUser(id: string): User {
  return database.findUser(id);
}

// Good - Command
function updateUser(id: string, data: UserData): void {
  database.updateUser(id, data);
}

// Avoid - Mixed responsibility
function getUserAndLog(id: string): User {
  const user = database.findUser(id);
  logger.info(`User ${id} accessed`); // Side effect in query
  return user;
}
```

### Control Flow

#### Early Returns
- Use early returns to avoid deep nesting
- Maximum nesting level: 2

```typescript
// Good
function processOrder(order: Order): void {
  if (!order) {
    throw new Error('Order is required');
  }
  
  if (!order.items.length) {
    throw new Error('Order must have items');
  }
  
  // Process order
}

// Avoid
function processOrder(order: Order): void {
  if (order) {
    if (order.items.length) {
      // Process order
    } else {
      throw new Error('Order must have items');
    }
  } else {
    throw new Error('Order is required');
  }
}
```

#### Flag Parameters
- Never use boolean flags to control function behavior
- Create separate functions instead

```typescript
// Good
function saveUser(user: User): void { }
function saveUserAsDraft(user: User): void { }

// Avoid
function saveUser(user: User, isDraft: boolean): void {
  if (isDraft) {
    // Save as draft
  } else {
    // Save normally
  }
}
```

## Code Size Limits

### Methods and Functions
- Maximum 50 lines per function
- If exceeding, consider extracting helper functions

### Classes
- Maximum 300 lines per class
- If exceeding, consider splitting responsibilities

## Dependency Management

### Dependency Inversion
- Always invert dependencies for external resources
- Apply in use cases and interface adapters
- Use interfaces to define contracts

```typescript
// Good
interface PaymentGateway {
  processPayment(amount: number): Promise<PaymentResult>;
}

class PaymentService {
  constructor(private gateway: PaymentGateway) {}
  
  async processOrder(order: Order): Promise<void> {
    await this.gateway.processPayment(order.total);
  }
}

// Avoid
class PaymentService {
  async processOrder(order: Order): Promise<void> {
    const stripe = new Stripe(); // Direct dependency
    await stripe.charge(order.total);
  }
}
```

## Code Formatting

### Blank Lines
- Avoid blank lines within methods and functions
- Use blank lines between methods/functions
- Group related code together

### Comments
- Avoid comments when possible
- Write self-documenting code instead
- Use comments only for:
  - Complex algorithms explanation
  - Business rule clarification
  - TODO/FIXME with ticket references

### Variable Declaration
- Never declare multiple variables on same line
- Declare variables close to where they're used

```typescript
// Good
const firstName = user.firstName;
const lastName = user.lastName;

// Avoid
const firstName = user.firstName, lastName = user.lastName;
```

## Design Principles

### Composition Over Inheritance
- Prefer composition to class inheritance
- Use interfaces for contracts
- Compose behaviors through dependency injection

```typescript
// Good - Composition
interface Logger {
  log(message: string): void;
}

class UserService {
  constructor(private logger: Logger) {}
}

// Avoid - Inheritance
class BaseService {
  protected log(message: string): void {}
}

class UserService extends BaseService {}
```

## Best Practices Summary

1. Write code in English with clear naming
2. Keep functions small and focused
3. Minimize nesting with early returns
4. Separate concerns clearly
5. Prefer composition over inheritance
6. Write self-documenting code
7. Apply SOLID principles consistently
8. Maintain consistent code style throughout the project